<link rel="import" href="../../../bower_components/polymer/polymer.html">

<dom-module id="webaudio-knob">

<style>
  :host {
      display: inline-block;

      width: 40px;
      height: 40px;
  }
  #knob {
    width: 100%;
    height: 100%;

    cursor: pointer;
    background-position-y: -64px;
    position: relative;
  }

  #value-tip {
    opacity: 0;
    border: solid 1px #666;
    background-color: #eee;
    position: absolute;
    top: 0;
    right: 0;
    padding: 1px 4px;
    font-size: 10px;
    font-family: Helvetica;
    transition: opacity 0.3s;
  }
</style>
  <template>
    <div id="knob" on-mousedown="mousedown">
      <span id="value-tip">{{value}}</span>
    </div>
  </template>
<script>
"use strict";

class WebAudioKnobElement {
    constructor() {
        this.startPos = null;
        this.startVal = 0;

        Polymer(WebAudioKnobElement.prototype);
    }

    get is() {
        return "webaudio-knob";
    }

    get properties() {
      return {
        startPos: {
            type:Number,
            value: 0
        },
        startVal: {
            type:Number,
            value: 0
        },
        value: {
            type:Number,
            value: 0
        },
        min: {
            type:Number,
            value: 0
        },
        max: {
            type:Number,
            value: 127
        },
        step:  {
            type:Number,
            value: 1
        },
        sprites: {
            type:Number,
            value: 24
        },
        src: {
            type:String,
            value: 'dist/web-components/webaudio-knob/plastic_knob.png'
        },
        isSprite: {
            type: Boolean,
            value: true
        }
      };
    }

    attached() {
        let sprite = new Image();
        sprite.onload = function() { this.calculeSprites(sprite); }.bind(this);
        sprite.src = this.src;

        this.$['knob'].style.backgroundImage = 'url('+this.src+')';
        this.$['knob'].style.backgroundSize = this.offsetSize() + "px";
    }

    calculeSprites(sprite) {
        this.isSprite = !(sprite.width == sprite.height);

        if (this.isSprite)
            this.sprites = sprite.height/sprite.width;
    }

    mousemove(e) {
      var offset = (this.startPos - e.pageY) || 0;
      var value = this.startVal + (e.shiftKey ? ~~(offset / 3) : this.step * offset);
      this.update.bind(this)(value);
    }

    cancel(e) {
        this.startPos = null;
        this.$['value-tip'].style.opacity = 0;
        window.removeEventListener('mousemove', this.boundMousemove, true);
        window.removeEventListener('mouseup', this.boundCancel, true);
        this.fire('cancel');
    }

    update(value) {
        this.value = value < this.min ? this.min : value > this.max ? this.max : value;

        let knob = this.$['knob'];
        if (this.isSprite)
            this.updateByImage(knob, this.value);
        else
            this.updateByRodate(knob, this.value);

        this.fire('change');
    }

    updateByImage(knob, value) {
        var range = this.max - this.min;
        var value = '-' + ~~(this.sprites / range * (range - this.min + this.value) + 1) * this.offsetSize() + 'px';

        if('backgroundPositionY' in knob.style)
            knob.style.backgroundPositionY = value;
        else
            knob.style.backgroundPosition="center " + value;
    }

    updateByRodate(knob, value) {
        let angle = this.calculeAngle(this.value);
        knob.style.transform = 'rotate('+angle+'deg)';
    }

    calculeAngle(value) {
        let angleMin = 30;
        let angleRange = 360 - 2 * angleMin;

        let range = this.max - this.min;
        return angleMin + angleRange * this.value / range;
    }

    ready() {
        this.update.bind(this)(this.value);
    }

    valueChanged(oldVal, newVal) {
        this.update.bind(this)(newVal);
    }

    mousedown(e) {
        this.$['value-tip'].style.opacity = 1;
        this.startPos = e.pageY;
        this.startVal = this.value;
        this.boundMousemove = this.mousemove.bind(this);
        this.boundCancel = this.cancel.bind(this);
        window.addEventListener('mousemove', this.boundMousemove, true);
        window.addEventListener('mouseup', this.boundCancel, true);
        e.preventDefault();
    }

    offsetSize() {
        let knob = this.$['knob'];
        let tamanho = knob.clientWidth < knob.clientHeight ? knob.clientWidth : knob.clientHeight;

        return tamanho;
    }
}

new WebAudioKnobElement();
</script>
</dom-module>
